MODULE gmsh_IO
!====================================================
!Description:
!Reads the mesh file
!Considers the mesh generated by the GMSH program
!(version 2)
!====================================================

use msg_IO

	contains
	subroutine read_mesh(mesh_filename,path,global_numbering,phys_region_ID,elem_type,nodes_coord,num_elements,num_nodes,num_elem_1D)
!====================================================
!Description: Reads the mesh file
!Variables:
!mesh_filename: mesh file name
!path: path of the mesh file
!global_numbering: global numbering of the nodes at
!each element
!phys_region_ID: physical ID of each element
!elem_type: type of each element (based on GMSH
!documentation)
!nodes_coord: coordinates of each node
!num_elements: total number of elements
!num_nodes: number of nodes
!num_elem_1D: number of elements 1-D
!====================================================
		implicit none
		
		character (len = *),intent(in) :: mesh_filename
		character (len = *),intent(in) :: path
		integer, allocatable,dimension(:,:),intent(inout) :: global_numbering
		integer, allocatable,dimension(:),intent(inout) :: phys_region_ID
		integer, allocatable,dimension(:),intent(inout) :: elem_type
		real, allocatable,dimension(:,:),intent(inout) :: nodes_coord
		integer,intent(inout)::num_elements
		integer,intent(inout)::num_nodes
		integer,intent(inout)::num_elem_1D

		
		integer,parameter::len_string=50
		integer::this_unit
		character(len=:), allocatable :: file_name
		character (len=len_string) :: this_line
		integer :: stat,num_tags
		integer :: start_reading_elem,stop_reading_elem,i,counter
		integer :: start_reading_nodes,stop_reading_nodes,counter_elem,counter_nodes

		real, allocatable,dimension(:) :: this_line_array
		logical :: file_exists


		real, dimension(4) :: this_coordinates
		logical:: start_reading_elem_bool,start_reading_nodes_bool
		start_reading_elem_bool=.False.
		start_reading_nodes_bool=.False.


!====================================================
!Read the file
!====================================================
		counter_elem=0
		counter_nodes=0
		counter=1
		file_name=trim(path) //'/'// trim(mesh_filename)
		

		open(newunit=this_unit, file = file_name, status = 'old', action = 'read', iostat = stat)
		
		if (stat == 0) then
			call write_msg('Reading the mesh file')	
			call write_msg('File:'//file_name)	
		end if
		
!Check the number of lines in the file
		 do
			read(this_unit, '(a)', iostat = stat) this_line
			
			if (stat /= 0) exit

			if (this_line=='$Elements') then
				start_reading_elem=counter+1
				start_reading_elem_bool=.True.
			end if

			if (this_line=='$EndElements') then
				stop_reading_elem=counter-1
				start_reading_elem_bool=.False.
			end if
			
			if (this_line=='$Nodes') then
				start_reading_nodes_bool=.True.
				start_reading_nodes=counter+1
			end if

			if (this_line=='$EndNodes') then
				start_reading_nodes_bool=.False.
				stop_reading_nodes=counter-1
			end if

!====================================================
!Gets the elements informations
!====================================================

!Gets the number of elements and allocates the arrays
			if ((counter==start_reading_elem) .and. start_reading_elem_bool )then
				read(this_line,*,iostat=stat)  num_elements
				
				allocate(global_numbering(num_elements,3))
				allocate(phys_region_ID(num_elements))
				allocate(elem_type(num_elements))
			end if
			
			if ((counter>=start_reading_elem) .and. start_reading_elem_bool )then
				call split_str_real(this_line,this_line_array)

! Type of the element
				elem_type(counter_elem)=this_line_array(2)
			
! Physical region ID and number of tags
				num_tags=int(this_line_array(3))
				phys_region_ID(counter_elem)=this_line_array(num_tags+2)
			
! Elements global numbering		
				global_numbering(counter_elem,:)=this_line_array(num_tags+4:)
			
				counter_elem=counter_elem+1
				if (allocated(this_line_array)) deallocate(this_line_array)
			end if
				
!====================================================
!Gets the nodes information
!====================================================

!Gets the number of nodes and allocates the arrays
			if ((counter==start_reading_nodes) .and. start_reading_nodes_bool )then
				read(this_line,*,iostat=stat)  num_nodes
				allocate(nodes_coord(num_nodes,3))
			end if
				

!Elements coordinates
			if ((counter>=start_reading_nodes) .and. start_reading_nodes_bool )then
			
				read(this_line,*,iostat=stat)  this_coordinates
				nodes_coord(counter_nodes,:)=this_coordinates(2:)
				counter_nodes=counter_nodes+1
			end if

		counter=counter+1
		
		end do

!Closes the file	
		close (this_unit)

		num_elem_1D=count(elem_type==1 .or. elem_type==8)

!====================================================
!Write the files to be ploted 
!====================================================

!Coordinates of the nodes
		file_name=trim(path) //'/'// 'points_coord.txt'
		INQUIRE(FILE=file_name, EXIST=file_exists)
		if (file_exists) then
			open(newunit=this_unit, file = file_name, status = 'old')
			else
			open(newunit=this_unit, file = file_name, status = 'new')
		end if
		
		do counter=1,num_nodes
		 	write(this_unit,*) nodes_coord(counter,:)
	 	end do
	 	close(this_unit)
	 	
!Triangulation
		file_name=trim(path) //'/'// 'triangulation.txt'
		INQUIRE(FILE=file_name, EXIST=file_exists)
		if (file_exists) then
			open(newunit=this_unit, file = file_name, status = 'old')
		else
			open(newunit=this_unit, file = file_name, status = 'new')
		end if
		
		do counter=num_elem_1D+1,num_elements
		 	write(this_unit,*) global_numbering(counter,:)
	 	end do
	 	close(this_unit)
	 	
!Region ID of the 2-D elements
		file_name=trim(path) //'/'// '2D_elem_phys_ID.txt'
		INQUIRE(FILE=file_name, EXIST=file_exists)
		if (file_exists) then
			open(newunit=this_unit, file = file_name, status = 'old')
		else
			open(newunit=this_unit, file = file_name, status = 'new')
		end if
		
		do counter=num_elem_1D+1,num_elements
		 	write(this_unit,*) phys_region_ID(counter)
	 	end do
	 	close(this_unit)
	
	call write_msg('Reading the mesh file - DONE')
	end subroutine


	subroutine split_str_real(this_line,this_line_array)
		character(len=*), intent(in) :: this_line
		real, allocatable,intent(in out),dimension(:) :: this_line_array
		character(len=2), parameter :: sep = ' '
		integer :: i,n,str_len
		character(:), allocatable :: str_line

!====================================================
!Deletes all the spaces after the information
!====================================================
		n = 1
		do i=1, len(this_line)
		   if (this_line(i:i) /= sep) then
		   	str_len=i
		   	end if
		end do
		str_line=this_line(1:str_len)

!====================================================
!Splits the string into a real type array
!====================================================
		n = 1
			do i=1, len(str_line)
			   if (str_line(i:i) == sep) n = n + 1
			end do
		allocate (this_line_array(n)) 
		read (unit=str_line,fmt=*) this_line_array

	end subroutine split_str_real

end module gmsh_IO
