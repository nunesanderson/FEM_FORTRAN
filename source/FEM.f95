module FEM
!====================================================
!Description: 
!The Finite Element solver
!====================================================

use gmsh_IO
use shape_functions
use msg_IO
use types, only:db_kind

implicit none
contains

	subroutine run_FEM(num_phys_regions,num_BCs,setup_phys_region_ID,setup_phys_region_perm_rel,&
	setup_phys_region_excitation,setup_phys_BC_ID,setup_phys_BC_val,&
	mesh_filename,path)
!====================================================
!Description: The Finite Element Solver
!Considers the mesh generated by the program GMSH
!!Variables:
!num_phys_regions: number of physical regions in the
!mesh
!num_BCs: number of boundary conditions applied
!setup_phys_region_ID: array with the physical regions
!IDs
!setup_phys_region_perm_rel: array with the permeabi_
!lity of each region
!setup_phys_region_excitation: array with the current
!density of each region
!setup_phys_BC_ID: array with the physical IDs of the
!boundary conditions
!setup_phys_BC_val: array with the values of the BCs
!mesh_filename: file name of the mesh
!path: path of the problem to be solved
!====================================================
	
!====================================================
!Variables
!====================================================
	
!Setup
	integer, intent(in):: num_phys_regions
	integer, intent(in):: num_BCs
	integer,dimension(:),intent(in):: setup_phys_region_ID
	real,dimension(:),intent(in):: setup_phys_region_perm_rel
	real,dimension(:),intent(in):: setup_phys_region_excitation
	integer,dimension(:),intent(in):: setup_phys_BC_ID
	real,dimension(:),intent(in):: setup_phys_BC_val
	character(len=*), intent(in) :: mesh_filename
	character(len=*), intent(in) :: path

!General
	integer,parameter:: num_nodes_per_element=3
	integer:: node_counter,elem_counter,global_node_ID
	integer::im,jm,integ_point_counter,info,this_phys_ID
	integer:: alloc_status

!Files control
	logical :: file_exists
	character(len=:), allocatable :: file_name
	integer::this_unit

!Jacobian and local matrices
	real(db_kind):: det_jac
	real(db_kind),dimension(num_nodes_per_element,2) :: coord_jac
	real(db_kind),dimension(2,2) :: jac
	real(db_kind),dimension(2,2) :: inv_jac
	real(db_kind),dimension(2,3) :: inv_jac_gradN
	real(db_kind),dimension(3,2) :: inv_jac_gradN_trans
	real(db_kind),dimension(3,3) :: local_left_side
	real(db_kind),dimension(3) :: local_right_side

!Left and right side of the linear equations system
	real(db_kind),allocatable,dimension(:,:) ::left_side
	real(db_kind),allocatable,dimension(:)::right_side
	integer,allocatable,dimension(:):: ipiv

!Material properties
	real(db_kind),  parameter :: PI  = 4.0 * atan (1.0)
	real(db_kind), parameter:: MU0=4*PI*0.00000001;

!Shape functions and integration 
	real(db_kind),allocatable,dimension(:,:):: mat_grad_N
	real(db_kind),allocatable,dimension(:):: mat_N
	integer::num_N
	real(db_kind),allocatable,dimension(:,:):: mat_integ_points
	real(db_kind),allocatable,dimension(:):: mat_integ_points_weight
	integer num_integ_points
	real ::permeability
	real ::current_density

!Mesh
	integer, allocatable,dimension(:,:)::global_numbering
	integer, allocatable,dimension(:):: phys_region_ID
	integer, allocatable,dimension(:) :: elem_type
	real, allocatable,dimension(:,:) :: nodes_coord
	integer::num_elements
	integer::num_nodes
	integer::num_elem_1D
	integer::pos(1)

!Boundary conditions
	integer, allocatable,dimension(:) :: nodes_ID_BC
	integer, allocatable,dimension(:) :: nodes_BC_val

!====================================================
!Starts solving the FEM Problem
!====================================================
	call write_msg('=====================================')	
	call write_msg('Solving the FEM problem')	
	call write_msg('Integration procedure')	

!Initialization of the variables
	call read_mesh(mesh_filename,path,global_numbering,phys_region_ID,elem_type,nodes_coord,num_elements,num_nodes,num_elem_1D)
	
!Depends on element order. In this case, first order	
	call grad_N_1_order(mat_grad_N)
	call integration_points(mat_integ_points_weight,mat_integ_points,num_integ_points)
	call N_nod_1_order(mat_N,mat_integ_points(1,1),mat_integ_points(1,2))

! ===================================
! Allocate the matrices
! ===================================
	alloc_status=0
	allocate(left_side(num_nodes,num_nodes),stat=alloc_status)
	allocate(right_side(num_nodes),stat=alloc_status)
	allocate(ipiv(num_nodes),stat=alloc_status)
	left_side=0
	right_side=0

	allocate(nodes_ID_BC(2*num_elem_1D))
	allocate(nodes_BC_val(2*num_elem_1D))
	nodes_ID_BC=0
	nodes_BC_val=0

!Check if the main matrices were allocated
	if (alloc_status/=0) then
		call write_msg('Problem in the memory allocation')	
	end if

! ===================================
! Main loop
! ===================================
	main_loop: do elem_counter=num_elem_1D+1,num_elements
		local_left_side=0
		local_right_side=0
		
!Element permeability
		this_phys_ID=phys_region_ID(elem_counter)
		pos=FINDLOC (setup_phys_region_ID, VALUE=this_phys_ID)
		permeability=MU0*setup_phys_region_perm_rel(pos(1))

!Current density
		current_density=setup_phys_region_excitation(pos(1))
		
! Jacobian calculation
		do node_counter=1,num_nodes_per_element
		    global_node_ID=global_numbering(elem_counter,node_counter)
		    coord_jac(node_counter,1)=nodes_coord(global_node_ID,1)
		    coord_jac(node_counter,2)=nodes_coord(global_node_ID,2)
		end do
		jac=matmul(mat_grad_N,coord_jac)

!Integration
		call matinv2(jac,inv_jac,det_jac)
		inv_jac_gradN=matmul(inv_jac,mat_grad_N)
		inv_jac_gradN_trans=transpose(inv_jac_gradN)
		
! Left side
		 do integ_point_counter=1,num_integ_points
			local_left_side=local_left_side+matmul(inv_jac_gradN_trans,inv_jac_gradN)*det_jac*&
			mat_integ_points_weight(integ_point_counter)*(1.0/permeability)
		end do

!Assembly
		do im=1,num_nodes_per_element 
		    do jm=1,num_nodes_per_element
		        left_side(global_numbering(elem_counter,im),global_numbering(elem_counter,jm))=&
		        left_side(global_numbering(elem_counter,im),global_numbering(elem_counter,jm))+local_left_side(im,jm)
		    end do
		end do
		
!Right side
		 do integ_point_counter=1,num_integ_points
			local_right_side=local_right_side+mat_N*det_jac*&
			mat_integ_points_weight(integ_point_counter)*current_density
		end do
		
!Assembly
		do im=1,num_nodes_per_element 
		        right_side(global_numbering(elem_counter,im))=right_side(global_numbering(elem_counter,im))+local_right_side(im)
		end do

	end do main_loop

	call write_msg('Integration procedure - DONE')
	call write_msg('Solving the linear system')

!====================================================
!Boundary conditions
!====================================================

!Gets the information about the nodes from the mesh
	pos(1)=0
	jm=1
	do elem_counter=1,num_elem_1D
		
		pos=FINDLOC (setup_phys_BC_ID, VALUE=phys_region_ID(elem_counter))
		
		do node_counter=1,2
			if (any(nodes_ID_BC==global_numbering(elem_counter,node_counter))) then
			else
			nodes_ID_BC(jm)=global_numbering(elem_counter,node_counter)
			nodes_BC_val(jm)=setup_phys_BC_val(pos(1))
			jm=jm+1
			end if
		end do
	end do

!Apply the boundary conditions
	do node_counter=1,2*num_elem_1D
		if(nodes_ID_BC(node_counter)>0)then
			jm=nodes_ID_BC(node_counter)
			left_side(jm,:)=0.0
			left_side(jm,jm)=1.0
			right_side(jm)=nodes_BC_val(node_counter)
		end if
	end do

!====================================================
!Solution of the linear system - LAPACK
!====================================================
	Call dgesv(num_nodes, 1, left_side, num_nodes, ipiv,right_side,num_nodes, info)
	call write_msg('Solving the linear system - DONE')
	call write_msg('Writing the solution file')

!====================================================
!Write the file solution
!====================================================
		file_name=trim(path) //'/'// 'solution.txt'
		INQUIRE(FILE=file_name, EXIST=file_exists)
		if (file_exists) then
			open(newunit=this_unit, file = file_name, status = 'old')
			else
			open(newunit=this_unit, file = file_name, status = 'new')
		end if
		
		do node_counter=1,num_nodes
		 	write(this_unit,*) right_side(node_counter)
	 	end do
	 	close(this_unit)
	call write_msg('Writing the solution file - DONE')

!====================================================
!Deallocate the matrices
!====================================================
	deallocate(left_side,right_side,ipiv,mat_grad_N)
	deallocate(mat_N,mat_integ_points,mat_integ_points_weight)
	deallocate(nodes_ID_BC,nodes_BC_val)
	call write_msg('Solving the FEM problem - DONE')	

end subroutine

subroutine print_matrix(mat,n_rows,n_cols)
!====================================================
!Description: Print a matrix based on the number of lines
!Variables:
!mat: matrix to be printed
!n_rows: number of lines
!n_cols: number of cols
!====================================================

    real, intent (in),dimension(n_rows,n_cols):: mat
    integer,intent(in):: n_rows
    integer,intent(in):: n_cols
	integer,dimension(2):: shape_mat
	integer::i

    do i=1,n_rows
        write(*,*)mat(i,:)
    end do

end subroutine print_matrix

subroutine matinv2(A,B,det)
!====================================================
!Description: Invert a 2X2 matrix
!Variables:
!A: matrix to be inverted
!B: matrix inverted
!det: determinant of A
!====================================================


! Performs a direct calculation of the inverse of a 2Ã—2 matrix.
	real(db_kind), intent(in),dimension(2,2)::A   !! Matrix
	real(db_kind), intent(out),dimension(2,2)::B  !! Inverse matrix
	real(db_kind), intent(out)::det  !! Inverse matrix
	real:: detinv

! Calculate the determinant of the matrix
	det=(A(1,1)*A(2,2) - A(1,2)*A(2,1))
	detinv = 1/det

! Calculate the inverse of the matrix
	B(1,1) = +detinv * A(2,2)
	B(2,1) = -detinv * A(2,1)
	B(1,2) = -detinv * A(1,2)
	B(2,2) = +detinv * A(1,1)
end subroutine

end module FEM
